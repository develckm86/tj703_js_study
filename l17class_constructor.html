<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>클래스와 생성자</title>
</head>
<body>
    <h1>클래스와 생성자와 Object</h1>
    <ul>
        <li>클래스 내부에 생성자는 오직 1개만 정의할 수 있다.</li>
        <li>Object 타입이 모든 자료형의 기본 형태가 된다.
            <ul>
                <li>let obj=new Object() -> { } 필드가 없는 빈자료형</li>
                <li>obj.name="경민" -> {name:"경민"}</li>
                <li>let obj={"name":"경민"};</li>
            </ul>
        </li>
        <li>생성자는 객체를 생성할때 무조건 호출된다.</li>
        <li>생성자를 객체를 초기화(초기값을 지정)할 때 사용한다</li>
        <li>생성자는 꼭 new 연산자로 호출해서 객체를 만든다.
            랩퍼클래스와 유틸클래스(Date)를 제외하고</li>
    </ul>
    <h2>클래스와 상속</h2>
    <ul>
        <li>모든 클래스는 Object 클래스를 상속받는다</li>
        <li>다른 클래스를 상속하면 상속(extends)받은 클래스의 모든 필드를 물려받는다.</li>
        <li>상속을 하는 이유 : 타입을 재사용하기 위해서  </li>
        <li>부모필드 접근자 super, 부모의생서자 super()</li>
        <li>
            자식의 객체를 만들때 생성자를 호출하면 부모의 생성자도 모두 호출되기 때문에 
            자식은 생성자를 정의할때 부모의 생성자를 꼭 호출해야한다.(나중에 실습으로 확인)
        </li>
    </ul>
    <script>
        class Test{}
        console.log(String("안녕"),Number(44),Boolean(1==1),Date());
        //console.log(Test());
        


class Member{
    constructor(id){
        this.id=id;
    }
    //constructor(){} 동일한 생성자를 두개를 쓸 수 없다.
    //constructor(name){} : 자바스크립트는 오버로딩이 불가능
    hello(name){ //class 안에서 function 을 생략 
        console.log(name+" 안녕하세요");
    }
    //상속받은 부모의 toString 과 동일한 이름을 작성해서 우선 순위를 보모보다 높인다.
    //Overriding(Override) : 재정의한다.
    toString(){ //객체에 대한 문자열 정보를 재정의하라고 만들어 놓은 함수
        //[object obejct]
        //super : Member 가 상속한 Object의 필드 접근자 
        //this :Member 필드 접근자
        return super.toString()+" 나는 id가 "+this.id+"인 객체야"; 
        //객체의 정보
    }
} //설계도 : class 평면적인 청사진
console.log(Member); //문자열만 출력 



let m=new Member("경민");
m.hello("상혁씨")
console.log(m.toString()); 
//Object.toString() :상속받은 필드를 사용할 수 있다
console.log(m);
console.log(m.valueOf()); //JSON 


let obj={}; //지정한 타입이 없는(Object) 빈 객체를 리터럴하게 생성
let obj2=new Object();
console.log(obj, obj2);
    //일반적인 상속
    class A{
        constructor(){
            this.a=10;
        }
    }
    //
    class B extends A{ //B가 A에게 상속받는다.
        constructor(){
            super(); 
            //부모가 생성자를 정의하면 자식이 생성자를 정의할때 부모생성자를 호출해야한다.(규칙)
            this.b=20;
        }
    }
    class C extends B{
        constructor(){
            super();
            this.c=30;
        }
    } 
    console.log(new A()); //{a:10}
    console.log(new B()); //{a:10,b:10}
    console.log(new C()); //{a:10,b:20,c:30} 
    
    //Object > A > B > C > D > E > F
    


    </script>
</body>
</html>